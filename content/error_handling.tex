In many cases, \openshmem routines will guarantee the correct completion of operations without any need for programs to check for error states, diagnose system problems, or retry operations. For example, there are no error codes returned for remote memory operations. The implementation is expected to internally attempt any feasible checking and recovery to best guarantee completion as specified. However, there are also cases where routines return error codes to allow programs to detect problems that may be correctable at the application layer, e.g. invalid arguments to routines or requests for system resources that cannot be fulfilled at runtime.

\CorCpp routines that return an integer error code follow the convention that \CONST{0} indicates successful local completion of the operation. This is considered a best effort of the implementation to indicate that all required local operations have been performed correctly inside the routine and the internal \openshmem state on the calling \ac{PE} is consistent with the description of the routine and its arguments upon completion. Implementations may use an integer return value from a routine to define other integer error codes specific to the implementation as long as those codes are not already explicitly defined for that routine.

Because \openshmem defines asynchronous communication operations, errors may not arise until sometime after the error-generating routine has returned control to the calling program. In these cases, the implementation might abort the application with an informative message or take other appropriate actions. So, a return value indicating success in a routine cannot be considered a guarantee that the routine will complete all future actions successfully.

Collective operations involving many \acp{PE} may return values indicating success while other \acp{PE} are still executing the collective operation. So, return values indicating success of a collective routine on one \ac{PE} do not by default indicate that all \acp{PE} involved in the collective operation will return from the routine successfully. If a collective routine provides any such global error checking behavior, it will be explicitly stated in the description of that routine.

\openshmem implementations for high performance production environments may do minimal internal error checking for performance reasons. Also, some errors may be undetectable or uncorrectable due to limitations in underlying technologies, resulting in undefined behaviors. For these reasons, \openshmem does not provide strict error checking guarantees in most cases. For \CorCpp routines returning integer error codes, implementations are expected to detect certain error conditions as explicitly defined in individual routines, then make best efforts to detect other problems in routine completion and return implementation specific nonzero error codes where feasible.

