The \acp{PE} in an \openshmem program can communicate either using
point-to-point routines that specify the \ac{PE} number of the target
\ac{PE} or using collective routines which operate over some predefined
set of \acp{PE}. Teams in \openshmem allow programs to group subsets
of \acp{PE} for collective communications and provide a contiguous reindexing
of the \acp{PE} within that subset that can be used in point-to-point communication.

An \openshmem team is a set of \acp{PE} defined by calling a specific team
split routine with a parent team argument and other arguments to further
specify how the parent team is to be split into one or more new teams.
A team created by a \FUNC{shmem\_team\_split\_*} routine can be used as the parent team
for a subsequent call to a team split routine.  A team persists and can
be used for multiple collective routine calls until it is destroyed by
\FUNC{shmem\_team\_destroy}.

Every team must have a least one member. Any attempt to create a team over an
empty set of \acp{PE} will result in no new team being created.

A ``team handle'' is an opaque object with type \CTYPE{shmem\_team\_t} that is used
to reference a defined team.  Team handles are created by one of the team split
routines and destroyed by the team destroy routine. Team handles have local
semantics only. That is, team handles should not be stored in shared variables
and used across other \acp{PE}. Doing so will result in undefined behavior.

By default, \openshmem creates predefined teams that will be available
for use once the routine \FUNC{shmem\_init} has been called. See
Section~\ref{subsec:library_handles} for a description of all predefined team handles
provided by \openshmem. Predefined \CTYPE{shmem\_team\_t} handles can be used as
the parent team when creating new \openshmem teams.

Every \ac{PE} is a member of the default team, which may be referenced
through the team handle \LibHandleRef{SHMEM\_TEAM\_WORLD},
and its number in the default team is equal to the
value of its \ac{PE} number as returned by \FUNC{shmem\_my\_pe}.

A special team handle value, \LibConstRef{SHMEM\_TEAM\_NULL}, may be used to
indicate that a returned team handle is not valid. This value can be tested
against to check for successful split operations and can be assigned to user
declared team handles as a sentinel value.

Teams that are created by a \FUNC{shmem\_team\_split\_*} routine may be
provided a configuration argument that specifies options that may affect
a team's capabilities and may allow for optimized performance.
This configuration argument is of type \CTYPE{shmem\_team\_config\_t}, which
is detailed further in Section~\ref{subsec:shmem_team_config_t}.

Team creation is a collective operation. As such, team creation in a
multithreaded environment follows the same semantics as discussed in section
\ref{subsec:thread_support}. Like other collectives, team creation is an action
of the \ac{PE} as a whole, and it is up to the programmer to ensure that each
\ac{PE} has consistent and predictable ordering of team creation calls over
all of its threads.

In addition to ordering requirements on team creation, there may also be
synchronization requirements.
\begin{itemize}
\item There is a special case where all new teams resulting from a split operation are
created with the \LibHandleRef{SHMEM\_TEAM\_NOCOLLECTIVE} option and are configured
to create \CONST{0} new contexts for the team. This means the team will \emph{not} be used
directly for point-to-point or collective communication routines, but only for
\ac{PE} number translation and further split operations. When creating new teams
of this type, no synchronization will be required around team creation operations.
\item In the case where a parent team uses multiple team split calls to create
multiple new teams which do not meet the above criteria for avoiding synchronization,
\emph{and} there is an overlap in team membership in the resulting new teams, all \acp{PE}
in the parent team must perform a barrier between team creation calls.
In other words, undefined behavior will result from allowing simultaneous execution of team
creation collective operations that split some team $T_0$ into multiple new
teams, $T_1, T_2...$, where some \ac{PE} $p$ exists such that $p \in T_1, p \in T_2, ...$.
By executing a barrier among the set of
all \acp{PE} in team $T_0$ between team creation operations, simultaneous execution
of split operations by those \acp{PE} is prevented. \ac{PE} $p$ will be ensured to
complete each split operation on $T_0$ before the next split operation on $T_0$ commences.
\item In the case where the above conditions hold to require a barrier on $T_0$,
but the parent team $T_0$ cannot be used for barriers due to having
been created with the \LibHandleRef{SHMEM\_TEAM\_NOCOLLECTIVE} option, the program may use any
ancestor team, e.g. \LibHandleRef{SHMEM\_TEAM\_WORLD}, for synchronization around new
team creation. The program may alternatively use some other custom synchronization method
as long as it ensures that each split collective completes for all \acp{PE}
in team $T_0$ before the next split on $T_0$ commences.
\end{itemize}

%% Teams may be created with options that change team behavior and may allow for
%% more optimized performance. These options are described in
%% Section~\ref{subsec:library_constants} and in the various descriptions of the
%% team split routines below. In particular, teams may be created with an option
%% to disable support for collective communications, which allows implementations
%% to reduce team creation overheads for those teams. In that case, the team is
%% just a local reindexing of some set of \acp{PE} that can be used for
%% point to point communications or as parent teams in subsequent split operations.
